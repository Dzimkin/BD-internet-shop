# BD-internet-shop
База данных "интернет_магазин" предназначена для автоматизации деятельности онлайн-торговой платформы, обеспечивая хранение, управление и обработку информации, связанной с товарами, заказами, пользователями, магазинами и логистикой.
В ней предусмотрены следующие сущности:
•	торговые_марки – хранит информацию о производителях или брендах, включая название, адрес и телефон.
•	категории_товаров – описывает и классифицирует товары по категориям (например, "электроника", "одежда").
•	товары – содержит сведения о каждом товаре: название, описание, цена, остаток на складе, принадлежность к категории и марке.
•	магазины – информация о физических точках продаж (название, адрес, контакты).
•	пункты_выдачи – пункты самовывоза, связанные с определённым магазином.
•	поставки – записи о поставках товаров в магазины, включая даты, статус и примечания.
•	товары_в_поставке – перечень товаров, входящих в конкретную поставку, с указанием их количества.
•	пользователи – содержит сведения о зарегистрированных клиентах интернет-магазина.
•	заказы – информация о заказах, оформленных пользователями, включая статус, дату, общую сумму и способ оплаты.
•	позиции_заказа – детализация заказа: какие товары и в каком количестве были заказаны.

В данной базе данных основные сущности находятся в отношениях «один ко многим». Например, одна категория товаров может включать множество товаров, одна торговая марка может быть связана с несколькими товарами, один магазин может иметь несколько пунктов выдачи и участвовать в нескольких поставках. Один пользователь может оформлять множество заказов, каждый заказ — содержать множество позиций.
Также реализовано отношение «многие ко многим» через связующую таблицу позиции_заказа, так как один заказ может включать несколько товаров, и один товар может встречаться в разных заказах. Аналогичным образом устроена таблица товары_в_поставке, где один товар может входить в состав разных поставок, а одна поставка — содержать разные товары.
Отношения «один к одному» в структуре базы данных отсутствуют.
База данных спроектирована с учётом логической целостности данных и бизнес-правил электронной коммерции, таких как учёт остатков, истории поставок и заказов, а также привязки к конкретным магазинам и пунктам выдачи.

Скрипты характерных выборок:
1. Общая сумма заказов по каждому пользователю:
SELECT p.имя, COUNT(z.id_заказа) AS кол_во_заказов, SUM(z.общая_сумма) AS сумма_заказов
FROM заказы z
JOIN пользователи p ON z.id_пользователя = p.id_пользователя
GROUP BY p.имя
ORDER BY сумма_заказов DESC;
2. Список товаров и сколько раз они были заказаны:
SELECT t.название AS товар, COUNT(pz.id_позиции) AS всего_раз_заказан
FROM позиции_заказа pz
JOIN товары t ON pz.id_товара = t.id_товара
GROUP BY t.название
ORDER BY всего_раз_заказан DESC;
3. Последние заказы каждого пользователя:
SELECT z.*
FROM заказы z
WHERE дата_заказа = (
  SELECT MAX(z2.дата_заказа)
  FROM заказы z2
  WHERE z2.id_пользователя = z.id_пользователя
);
4. Количество товаров в каждой поставке:
SELECT ps.id_поставки, m.название AS магазин, COUNT(tvp.id_товара) AS всего_товаров
FROM поставки ps
JOIN магазины m ON ps.id_магазина = m.id_магазина
JOIN товары_в_поставке tvp ON ps.id_поставки = tvp.id_поставки
GROUP BY ps.id_поставки, m.название;
5. Количество заказов в каждом магазине:
SELECT m.город, m.название, COUNT(z.id_заказа) AS количество_заказов
FROM заказы z
JOIN магазины m ON z.id_магазина = m.id_магазина
GROUP BY m.город, m.название
ORDER BY количество_заказов DESC;

6. Товары, которых меньше 30 на складе:
SELECT t.название, t.количество_на_складе, c.название AS категория, tm.название AS марка
FROM товары t
JOIN категории_товаров c ON t.id_категории = c.id_категории
LEFT JOIN торговые_марки tm ON t.id_марки = tm.id_марки
WHERE t.количество_на_складе < 30;

7. Заказы с позицией самого дорогого товара:
SELECT z.id_заказа, t.название, pz.цена_за_единицу
FROM позиции_заказа pz
JOIN заказы z ON pz.id_заказа = z.id_заказа
JOIN товары t ON pz.id_товара = t.id_товара
WHERE pz.цена_за_единицу = (
  SELECT MAX(цена_за_единицу)
  FROM позиции_заказа
);
 
 Представление 
1.	Заказы_по_пользователям
Содержит информацию по заказам пользователей: имя, email, количество заказов и общая сумма.
CREATE OR REPLACE VIEW заказы_по_пользователям AS
SELECT 
    p.id_пользователя,
    p.имя,
    p.email,
    COUNT(z.id_заказа) AS количество_заказов,
    SUM(z.общая_сумма) AS сумма_заказов
FROM пользователи p
LEFT JOIN заказы z ON p.id_пользователя = z.id_пользователя
GROUP BY p.id_пользователя, p.имя, p.email;

2. Популярные_товары
Показывает товары, отсортированные по количеству продаж (на основе позиций в заказах).
CREATE OR REPLACE VIEW популярные_товары AS
SELECT 
    t.id_товара,
    t.название,
    SUM(pz.количество) AS всего_продано,
    COUNT(DISTINCT pz.id_заказа) AS кол_заказов
FROM позиции_заказа pz
JOIN товары t ON pz.id_товара = t.id_товара
GROUP BY t.id_товара, t.название
ORDER BY всего_продано DESC;
 
 Хранимые процедуры добавление нового пользователя
DELIMITER //
DROP PROCEDURE IF EXISTS добавить_пользователя//
CREATE PROCEDURE добавить_пользователя (
    IN имя_п VARCHAR(50),
    IN email_п VARCHAR(100),
    IN телефон_п VARCHAR(20),
    IN адрес_п VARCHAR(255),
    IN пароль_п VARCHAR(255)
)
BEGIN
    INSERT INTO пользователи (имя, email, телефон, адрес, пароль)
    VALUES ('Дмитрий Самсонов', 'user12@email.by', '+375293008327', 'Минск, пр. Независимости, д.48', 'password123');
END//


Триггер добавления пользователя
DELIMITER //
CREATE TRIGGER `пользователи_количество` 
AFTER INSERT ON `пользователи`
FOR EACH ROW
BEGIN
  SELECT COUNT(*) INTO @total FROM `пользователи`;
END//

DELIMITER ;

INSERT INTO `пользователи` (`имя`, `email`, `телефон`, `адрес`, `пароль`) 
VALUES ('Дмитрий Самсонов', 'user13@email.by', '+375293008328', 'Минск, пр. Независимости, д.48', 'password123');
